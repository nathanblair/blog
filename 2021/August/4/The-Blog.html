<p>
  Hosting your blog source files separately from your website source files using
  only <code>git</code> and GitHub Pages - it can't be done!
</p>

<p>
  That's what I was becoming convinced of. I've done some hacking and it turns
  out, with even just a pretty simple flow, it <em>can</em> in fact be done.
</p>

<h1>The Why</h1>

<p>
  I think we can all agree separation of concern is a good thing; and that its
  much easier to only need to concern yourself with publishing an
  <code class="lang-html">html</code> file rather than an entire website.
</p>

<p>
  In addition, blog content should be source-controlled and done so separately
  from the actual website that hosts it. This permits easy and quick
  modification to article content without needing to redeploy an otherwise
  static website for fixing something like a tiny spelling error (like the one I
  just had to fix when I almost published <em>modificaiton</em>...).
</p>

<p>
  The way we will set this source-control directory structure up, we can have
  multiple branches open while working on multiple blog posts. Merging them will
  hardly ever create a merge conflict!
</p>

<h2>Blog Article Behaviors</h2>

<p>
  In my eyes, I think it is reasonable and intuitive when visiting a Blog to be
  greeted with some placeholder/skeleton article snippets while the actual
  articles load from their cloud storage. This makes any period of needing to
  wait a <em>little</em> more UX-friendly
</p>

<p>
  Once they load, I can view the list of blogs, with their populated date,
  title, and a snippet of them spanning some section of time. Some control(s)
  would be available to assist in narrowing down the stretch of time from which
  to populate articles from. Perhaps even a generic search field in case Google
  wasn't doing quite a good enough job...
</p>

<p>
  I can peruse the article list at my discretion and should I find something
  that sounds intereseting to read, I would like to click on that snippet and
  view the full article contents without losing my context of where I am in
  browsing the blog list.
</p>

<p>
  It would also be a worthy accessibility goal to enable the articles to work
  with browser Reader views.
</p>

<h1>The Workflow</h1>

<h2>Overview</h2>

<ul>
  <li>
    Write blog source files and organize them in a directory structure
    representing their date of publish and with a filename that represents their
    title.
  </li>

  <li>
    Initalize remote source control repository if not done already. GitHub works
    very well for this as their API to list directories and grab files from
    repositories is very simple to consume. But I've hacked around to make it
    work using something like Google Firestore as well, and I'm sure S3 buckets
    could potentially work too.
  </li>

  <li>
    Initialize the local source control repository. Add the remote repository
    created in the latter step to this local repository.
  </li>

  <li>
    Add the diff created when writing the blog, commit it, and push your local
    changes to your remote repository. If your Cloud Storage host is different
    from your remote repository, you will need additional steps to copy the
    article from source to its Cloud Storage destination.
  </li>

  <li>
    Publish website that can make API calls to list and download blog source
    (<code class="lang-html">html</code>) files.
  </li>
</ul>

<h2>The Details</h2>

<h3>Cloud Storage</h3>

<p>
  The first order of business is to create the hosting environment for where the
  blog source (i.e. the <code class="lang-html">html</code>) files will actually
  reside. This can work using Cloud Storage solutions like S3 or Google
  Firestore but I find its most efficient to use a GitHub repository, as their
  API is very easy to consume and no extra steps are needed once the local
  source control is synced with the cloud.
</p>

<aside>
  Discussing setting up for a cloud storage host other than GitHub is outside
  the scope of this blog post. If people are interested in how Google Firestore
  or AWS S3 might work, send me a mention
  <a href="https://twitter.com/NateTBlair">@NateTBlair</a>
</aside>

<h4>GitHub</h4>

<p>
  For GitHub, its a simple matter of creating a repository that's solely meant
  for source-controlling your blog post source files (the
  <code class="lang-html">html</code> files). e.g. these very blog articles
  reside in a <code>blog</code> repository in
  <a href="https://github.com/nathanblair">my personal GitHub account.</a>
</p>

<p>
  This method is most effective (and the assumption throughout the rest of the
  guide) when with this directory structure. Its very simple:
</p>

<ul>
  <li>
    <code>Year</code>
    <ul>
      <li>
        <code>Month</code>
        <ul>
          <li>
            <code>Day</code>
            <ul>
              <li>
                <code>Blog-Post.html</code>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>
  This will end up with a blog post shown on the website for the date
  <code class="lang-js">${Day} ${Month} ${Year}</code> and the title
  <b>Blog Post</b>.
</p>

<p>
  Feel free to either create the repository in GitHub first and clone it down or
  initialize the local <code>git</code> repo and add the created GitHub remote
  repository to the existing local one.
</p>

<p>
  Make sure you are set to commit and sync to your remote's default branch. I
  have my configuration set to
  <code>git config --global init.defaultBranch "default"</code>) and use the
  name <code>github</code> for all my remotes that are in GitHub. When I push
  and set my upstream tracking branch I run
  <code>git push -u github default</code>.
</p>

<!-- Turn this into an ordered list? -->
<p>
  Write the <code>Blog-Post.html</code> file at the desired date folder
  structure location, then:
</p>

<pre><code>  git add ${Year}/${Month}/${Day}/Blog-Post.html
  git commit -m "${YOUR_COMMIT_MESSAGE}"
  git push # u ${REMOTE_NAME} ${DEFAULT_BRANCH} (if you're not already set up to sync to that branch by default).
</code></pre>

<p>
  This takes care of everything that needs to be done to the blog article
  <code class="lang-html">html</code> file itself. With the source now available
  from a Cloud Storage host, we just need to fetch it and insert it into our
  Blog page.
</p>

<h3>Website Blog Page Logic</h3>

<p>
  The details of this will be very dependent upon how your site is designed and
  what kind of frameworks you use. I can't account for all UI Frameworks in a
  single article so I'll divulge my process while using
  <code><a href="https://svelte.dev/">svelte</a></code> and you can feel free to
  modify the process to fit your needs accordingly.
</p>

<h4>Svelte Pages and Routing</h4>

<p>
  I don't use any extra-special <code>svelte</code> frameworks to manage
  routing. I have a <code>blog/index.html</code> path inside my hosted root
  folder, and that <code>index.html</code> file points to the same
  <code>main.js</code> and other assets that my <code>/index.html</code> file
  does. In the end, it ends up just serving my
  <code>Blog.svelte</code> component. To see it in action, check out my
  <code
    ><a
      href="https://github.com/nathanblair/nathanblair.github.io/blob/default/src/App.svelte"
      >App.svelte</a
    ></code
  >
  file and my
  <code
    ><a
      href="https://github.com/nathanblair/nathanblair.github.io/blob/default/src/pages/Blog.svelte"
      >pages/Blog.svelte</a
    ></code
  >
  file.
</p>

<p>
  Speaking of that <code>pages/Blog.svelte</code> file, let's dive into what its
  doing to load our Blog articles from the Cloud Storage host.
</p>

<h4>
  <a name="BlogPage"></a>
  <code>pages/Blog.svelte</code>
</h4>

<p>
  Most of the functionality for network requests is actually handled in a
  Javascript module located in <code>src/blog.js</code>, but let's first dig
  into what must be done from a high-level before digging into the
  implementation details.
</p>

<p>
  The first thing we need is a DOM element for targeting where to insert each
  Blog Article from the <code>pages/Blog.svelte</code> Component. For my DOM,
  they are set up to target the <code class="lang-html">main</code> element. It
  may be appropriate to target your blog articles to your
  <code class="lang-js">document.body</code>.
</p>

<p>
  The next piece of information we'll need is to evaluate the current context to
  determine what kind of filter to use to fetch blog articles.
</p>

<p>
  For example, we need to know if our current
  <code class="lang-js">window.location</code> indicates the user is attempting
  to view a single article directly on page load. Otherwise, we'll want to fetch
  a mixture of blog articles using some default time range filter.
</p>

<p>
  This filter, in turn, is what we'll be using in our API calls that fetch the
  actual article source files. Note that we've set up the blog directory
  structure for relatively easy querying. If you're using something like
  Firestore or another Cloud Storage you could take advantage of different query
  indices to optimize the API calls you're making and better tailor your
  filtering function.
</p>

<p>
  The first logic check when rendering the
  <code>pages/Blog.svelte</code> Component loads is then to have a look at the
  <code class="lang-js">window.location.hash</code>.
</p>

<pre><code class="lang-html">  {#if window.location.hash === ""}
  ...
  {/if}
</code></pre>

<p>
  Next, we're going to render a predefined array of Blog Placeholder/Skeleton
  elements to the page while the network requests occur to fetch the actual
  articles.
</p>

<h5>Blog Placeholders</h5>

<h6>Logic</h6>

<p>
  It makes the most sense to me to paginate articles per month. No month has
  more than 31 days, so will be inserting 31 placeholder/skeleton elements that
  should tide the user over while the articles are fetched in the background.
</p>

<p>
  These placeholders also double as anchors for the
  <code>BlogArticle</code> Components themselves as we will see in a moment.
</p>

<p>
  We want to make sure each placeholder is only inserted when we're attempting
  to get a list of articles and not viewing a single article's content. Thus, we
  will insert this <code>svelte</code> <code class="lang-js">each</code> block
  insert the previously discussed
  <code class="lang-js">window.location.hash</code> guard:
</p>

<pre><code class="lang-html">  {#if window.location.hash === ""}
    {#each month_days as each_day}
      &lt;BlogPlaceholder id={get_skeleton_id(each_day)} /&gt;
    {/each}
  {/if}
</code></pre>

<p>Where <code class="lang-js">month_days</code> comes from this declartion:</p>

<pre><code class="lang-js">  /**
   * For reverse-chronological sorting order
   *
   * @type {number[]}
   * */
  const month_days = Array.from(
    { length: total_days },
    (_, i) => total_days - i
  )
</code></pre>

<p>And obviously <code class="lang-js">const total_days = 31</code>.</p>

<p>
  The <code class="lang-js">get_skeleton_id</code> is a very simple function
  that maps a number parameter to something that could be used as an
  <code class="lang-html">id</code>. It looks like:
</p>

<pre><code class="lang-js">  /** @param {number} index */
  function get_skeleton_id(index) {
    return "day-" + index
  }
</code></pre>

<h6>Component</h6>

<p>
  Since the Component will just be a placeholder/skeleton for the articles
  themselves, its helpful to lay it out in a manner identical to how the
  articles will look. Then we'll just fill in the text placeholder divs with
  some padding and color.
</p>

<pre><code class="lang-html">  &lt;div {id} class="{card_class_name} {blog_placeholder_class_name} article-skeleton"&gt;
    &lt;header&gt;
      &lt;div
        class="h1-skeleton {skeleton_background_color_class_name} {skeleton_border_class_name}"
      /&gt;
      &lt;div
        class="h2-skeleton {skeleton_background_color_class_name} {skeleton_border_class_name}"
      /&gt;
    &lt;/header&gt;
    &lt;p
      class="{skeleton_background_color_class_name} {skeleton_border_class_name}"
    /&gt;
    &lt;p
      class="{skeleton_background_color_class_name} {skeleton_border_class_name}"
    /&gt;
  &lt;/div&gt;
</code></pre>

<p>
  Where <code class="lang-js">skeleton_background_color_class_name</code> and
  <code class="lang-js">skeleton_border_class_name</code> are simply set to:
</p>

<pre><code class="lang-js">  const skeleton_background_color_class_name = "skeleton-background-color"
  const skeleton_border_class_name = "skeleton-border"
</code></pre>

<p>
  and are just convenience aliases for consistent reference across multiple
  elements.
</p>

<p>
  The styling is largely up to personal taste but to get you started, mine look
  like:
</p>

<pre><code class="lang-css">  .skeleton-background-color {
    background: lightgray;
  }

  .skeleton-border {
    border-radius: 8px;
  }

  .article-skeleton {
    height: 35vh;
    padding: 1vh 4vw;
    overflow: hidden;
  }

  .h1-skeleton {
    width: 40%;
  }

  .h2-skeleton {
    width: 60%;
  }

  .h1-skeleton,
  .h2-skeleton {
    padding: 1vh 0;
    margin: 8px 0;
    height: 40px;
  }

  p {
    height: 40px;
    margin-top: 5%;
  }
</code></pre>

<p>
  That will get us some decent-looking placeholders/skeletons upon the Blog page
  loading. But how do we replace them with the actual articles?
</p>

<h5>Blog Articles</h5>

<p>
  The blog page will initially render with those placeholders/skeletons, but
  looking at those isn't why someone is visiting the Blog page. So let's
  actually <code class="lang-js">populate_blogs</code>.
</p>

<p>
  <code class="lang-js">populate_blogs</code> will serve as an async function
  that we can just leave called at the end of our
  <code>pages/Blog.svelte</code> Component script:
</p>

<pre><code class="lang-js">  ...
  populate_blogs()
  ...
</code></pre>

<p>And the actual function looks like:</p>

<pre><code class="lang-js">  async function populate_blogs() {
    const fragment = extract_filter_from_fragment()
    let filter = fragment === "" ? default_filter : () => fragment

    for await (const each_article of fetch_blog_articles(filter)) {
      const skeleton_id = get_skeleton_id(parseInt(each_article.date[2]))
      const anchor = document.getElementById(skeleton_id)

      new BlogArticle({
        target: document.getElementById(main_id) || document.body,
        // @ts-ignore
        anchor: anchor,
        props: {
          blog_file_name: each_article.file_name,
          date: each_article.date,
          content: each_article.content,
        },
      })

      anchor?.remove()
    }

    const placeholders = document.querySelectorAll(
      "." + blog_placeholder_class_name
    )

    placeholders.forEach(async (each_placeholder, _) => {
      each_placeholder.classList.add(transition_opacity_class_name)
      await new Promise((resolve) => setTimeout(resolve, ux_wait_time))
      each_placeholder.remove()
    })
  }
</code></pre>

<p>There's quite a lot to dissect there so let's break it down.</p>

<p>
  First, the <code class="lang-js">extract_filter_from_fragment</code> function
  will check the fragment/hash of the URL to determine if the filter needs to
  pull a specific article or a list.
</p>

<pre><code class="lang-js">  function extract_filter_from_fragment() {
    return window.location.hash
      .replace(/^#/, "")
      .split("-")
      .slice(0, 3)
      .join("/")
  }
</code></pre>

<p>
  The string operations going on here will make more sense later once we discuss
  how we set the <code class="lang-html">id</code> of each blog article.
  Essentially, we're stripping out the first 3 sections out of the url fragment
  (delineated by <code>-</code>'s), which encode the
  <code class="lang-js">${DAY}</code>, <code class="lang-js">${MONTH}</code>,
  and <code class="lang-js">${YEAR}</code> and reformatting them into a string
  of the format <code class="lang-js">"${YEAR}/${MONTH}/${DAY}"</code>. This is
  compatible with the way we're able to "query" data using the GitHub API and it
  fits our directory model.
</p>

<p>&#128077;</p>

<p>
  We'll cache this result in
  <code class="lang-js">const fragment = extract_filter_from_fragment()</code>
  and then check if that returns empty. If it does not, we know that's what we
  should set the filter to, otherwise, we'll use a default filter to fetch some
  timeline of blog articles. Again, that default filter will bring in all
  articles for the current month, and we'll cover that implementation
  momentarily. Eventually we would also like to present the user with some
  controls to change with month the articles are pulled in from as well as a
  generic search function.
</p>

<p>
  So far though, what we have covers the
  <code class="lang-js">filter</code> case that we can utilize for now:
</p>

<pre><code class="lang-js">  let filter = fragment === "" ? default_filter : () => fragment</code></pre>

<p>
  Note that the <code class="lang-js">filter</code> is cached to a callback.
  <code class="lang-js">default_filter</code> is some function at our discretion
  that will pull in some desired amount/timeline of blog articles.
</p>

<p>
  We can now concern ourselves with passing in our
  <code class="lang-js">filter</code> callback function to
  <code class="lang-js">fetch_blog_articles</code> which will return an async
  iterable of blog articles. Specifically, I like the idea of using
  <code class="lang-js">AsyncGenerators</code> to
  <code class="lang-js">yield</code> each Article as it is processed from the
  Cloud Storage, and so under the hood, our
  <code class="lang-js">for</code> loop that iterates on each retrieved article
  will be iterating over an <code class="lang-js">AsyncGenerator</code>. Again,
  we'll take a look at this function more later.
</p>

<p>
  Suffice it to say each <code class="lang-js">yield</code>ed article contains
  enough information for us to create a
  <code class="lang-js">new BlogArticle</code>. Most of that returned
  <code class="lang-js">each_article</code>'s properties will be copied to the
  <code class="lang-js">BlogArticle</code> Component's properties.
</p>

<p>
  For instantiating the rest of the <code class="lang-js">BlogArticle</code>,
  <code>svelte</code> requires a target where that Component will be appended.
  For this target, we again can use whatever in the DOM makes the most sense.
  For my page and setup, I append my articles to the
  <code class="lang-html">main</code> element.
</p>

<p>
  But appending to the body does not handle reverse-chronological sorting. And
  this is why we've created the <code class="lang-js">month_days</code> array
  the way we have and inserted the <code>BlogArticles</code> in the method we
  did.
</p>

<p>
  <code>svelte</code>, in addition to having a Component instance
  <code class="lang-js">target</code>, can also have a Component instance
  <code class="lang-js">anchor</code>.
</p>

<p>
  Our <code>BlogArticles</code> are going to serve as the anchor elements to
  pass to this instance <code class="lang-js">anchor</code> parameter. In order
  to get a reference to those elements though, we need their
  <code class="lang-html">id</code>. Again, this is where the
  <code class="lang-js">get_skeleton_id</code> function is useful.
</p>

<p>
  We can cache the <code class="lang-js">skeleton_id</code> of the corresponding
  <code>BlogPlaceholder</code> Component by using
  <code class="lang-js">each_article</code>'s
  <code class="lang-js">date[2]</code>, which translates to the article's day,
  into the call to <code class="lang-js">get_skeleton_id</code>. Then we simply
  use that cached <code class="lang-html">id</code> to grab the element from the
  DOM using the function <code class="lang-js">document.getElementById</code>.
</p>

<p>
  This gives us a handle to the <code class="lang-js">anchor</code> element we
  need to fully instantiate a <code class="lang-js">BlogArticle</code>.
</p>

<p>
  After we have created and added the <code>BlogArticle</code> Component to the
  DOM, we just need to <code class="lang-js">anchor?.remove()</code>, which
  removes the <code class="lang-js">anchor</code> element the
  <code>BlogArticle</code>used to properly sort itself.
</p>

<p>
  That wraps up actually adding the <code>BlogArticle</code> Components and
  their contents to the page. We just need to finish cleaning up all the
  leftover placeholders.
</p>

<p>
  For this operation, I find the best user experience to be using an
  asynchronous <code class="lang-js">forEach</code> call upon all the existing
  <code>BlogArticle</code> DOM elements. I find it also makes for a more
  consistent user experience to also add in a brief UX-friendly
  <code>sleep</code> period between each element's removal, as it helps to
  emphasize to the user that work was being done and is now finished.
</p>

<p>
  Right before the element is removed (before the <code>sleep</code> operation
  occurs), I add a class that performs a nice little "fade" to each
  <code>BlogPlaceholder</code> that assists in this UX. The wait time needn't be
  any longer than 250ms. And since this is an
  <code class="lang-js">async forEach</code> loop, the wait time won't be the
  serial combination of 30+ <code>sleep for 250ms</code> calls, but rather,
  something close to a total time of 250ms for the entire operation.
</p>

<h4><code>components/BlogArticle.svelte</code></h4>

<p>
  With the main Blog page set up to fetch blog articles, its now appropriate to
  lay out what each article will look like. <code>Svelte</code> makes templating
  up each article into a similar layout and design a very trivial task.
</p>

<p>
  Taking a look at the most basic properties of a <code>BlogArticle</code>, we
  obviously have a "Blog Article Title" as well as a "Blog Article Date", and
  obviously the "Content" itself.
</p>

<p>
  The title of the blog is a parsed value that comes from the article file name
  as it is in the Cloud Storage provider. We'll handle parsing the file name
  into the title itself a little later, but for now we know we need to expose a
  property for the file name to be set when instantiating the Component.
</p>

<p>
  You're free to represent your dates the way you want to; its easiest to keep
  the date format consistent between how its displayed in the blog page and how
  you store it in the original blog repository. e.g. I display my blogs in the
  format
  <code class="lang-js">"${DD} ${FULL_MONTH} ${YEAR}"</code>. But you could
  display them as <code class="lang-js">"${DD} ${MM} ${YY}"</code> if that
  suited your intuition better. Either way, we'll expose a
  <code>date</code> property for passing in the date of the blog article, known
  at the time of fetching it from the Cloud Storage provider as it will be the
  path to the actual file.
</p>

<p>
  Since we're not allowed to pass in slots directly when we instantiate Svelte
  Components from Javascript, we'll also have to pass in the
  <code class="lang-html">html</code> content of the blog as a Component
  property. We'll then need to expose a
  <code class="lang-html">content</code> property for passing in the raw
  <code class="lang-html">html</code> content of the retrieved file.
</p>

<p>
  That covers the input properties of the <code>BlogArticle</code> Component
  that it needs to create itself. Note that these are consistent with the
  properties set when we instantiate the <code>BlogArticle</code> from the
  <a href="#BlogPage"><code>pages/Blog.svelte</code> Component</a>.
</p>

<pre><code class="lang-html">  // components/BlogArticle.svelte
  &lt;script&gt;
    ...

    /** @type {string} */
    export let blog_file_name

    /** @type {import("../blog.js").ArticleDateArray} */
    export let date

    /** @type {string} */
    export let content

    ...
  &lt;script&gt;

  ...
</code></pre>

<p>
  We know the properties the BlogArticle will need to display, so let's wire up
  the layout for it.
</p>

<pre><code class="lang-html">  &lt;article {id} class="{card_class} {snippet_class_name} {article_class_list}" &gt;
    &lt;header&gt;
      &lt;h1 class="article-date">{day} {month} {year}&lt;/h1&gt;
      &lt;h2 class="article-title">{parse_blog_file_name()}&lt;/h2&gt;
    &lt;/header&gt;
    {@html content}
    {#if !full_article_shown}
      &lt;a href={"#" + id} target="_blank" class="overlay">Read More&lt;/a&gt;
    {:else}
      &lt;script
        defer
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"&gt;&lt;/script&gt;
      &lt;script
        defer
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.js"&gt;&lt;/script&gt;
    {/if}
  &lt;/article&gt;
</code></pre>

<p>
  There's quite a bit buried in there that hasn't been addressed yet, so let's
  pick it apart. Starting with the <code class="lang-html">header</code> as that
  is the information we just finished setting up to be collected.
</p>

<p>
  The <code class="lang-html">header</code> has two values it displays: the
  "Blog Article Title" and the "Blog Date".
</p>

<h4>Blog Date</h4>

<p>
  The Blog Date is a trivial substituion whose components are
  <code class="lang-js">const</code>ants set from parsing our input property
  <code>date</code>. Its very simply:
</p>

<pre><code class="lang-js">  const year = date[0]
  const month = date[1]
  const day = date[2]
</code></pre>

<h4>Blog Title</h4>

<p>
  As mentioned previously, there's a little more parsing going on here to
  generate the Blog Title, but we have all the information we need to parse it.
  We're simply looking at the <code class="lang-js">blog_file_name</code> input
  parameter and doing some very trivial string operations on it:
</p>

<pre><code class="lang-js">  function parse_blog_file_name() {
    return id.split("-").slice(3).join(" ")
  }
</code></pre>

<p>
  You should notice the <code class="lang-js">blog_file_name</code> isn't used
  directly, but instead the <code class="lang-html">id</code>. This
  <code class="lang-html">id</code> will be the
  <code class="lang-html">id</code> attribute of the article and it is
  calculated from another couple simple string operations:
</p>

<pre><code class="lang-js">  const id = year + "-" + month + "-" + day + "-" + blog_file_name.replace(".html", "")</code></pre>

<p>
  We'll get more into the <code class="lang-html">id</code> in just a moment,
  but returning to the <code class="lang-js">parse_blog_file_name</code> we can
  see the rest of the function is just a string operation. Namely, it strips off
  the <code>date</code> data from the <code class="lang-html">id</code> and then
  joins the remaining array together with spaces between, creating a proper
  "Blog Title".
</p>

<h4>Tracking Desire to View A Single Article</h4>

<p>
  If there's a desire to view only a single blog article, the
  <code class="lang-js">window.location.hash</code> will be set to the
  <code class="lang-html">id</code> of the article.
</p>

<p>
  We can then use <code class="lang-js">full_article_shown</code> to set up a
  couple different scenarios.
</p>

<p>
  One of the parameters that depends upon the
  <code class="lang-js">full_article_shown</code> state is whether to show the
  <code class="lang-html">article</code> element as a "card". This is simply a
  styling choice to give each <code class="lang-html">article</code> a look of
  being raised from the page slightly, which makes the link-clicking behavior
  more intuitive.
</p>

<p>
  The other parameter is whether or not to stylize the article listing as a
  "snippet". This would mean there is a
  <code class="lang-css">max-height</code> set on the
  <code class="lang-html">article</code> element.
</p>

<p>
  If the full article is not displayed, at the lower portion of the "snippet", I
  create an "overlay"
  <code class="lang-html">a</code> element which fades the content behind it and
  when clicked, opens the article in a new tab on the user agent. This helps to
  allow the user to not lose their place in the blog list while also allowing
  quick context switching to the article itself. I find I always end up opening
  articles in their own tab anyway, so why not mitigate that middle step?
</p>

<p>
  If the full article <em>is</em> displayed, I've embedded some Javascript
  libraries hosted from a CDN that will parse &lt;code\&gt; elements for me and
  provide syntax-highlight on the <code>code</code> snippets, with
  language-appropriate highlighting considered.
</p>

<p>Altogether, they look like:</p>

<pre><code class="lang-js">  // Inside script tag of Component
  ...
  const full_article_shown = window.location.hash.replace("#", "") === id
  const card_class = full_article_shown ? "" : "card"
  const snippet_class_name = full_article_shown ? "" : "snippet"
  ...
</code></pre>

<p>
  Other styling applied like the <code class="lang-css">overlay</code> and
  <code class="lang-css">snippet</code> classes are used for helping to create a
  "snippet"-style look of the article in the list of articles.
</p>

<pre><code class="lang-css">  /* Component style tag */
  .card {
    border: solid 1px;
    box-shadow: 0 0 4px;
    padding: 2vh;
    margin: 2vh 2vw;
  }

  .overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    z-index: 1;
    font-size: 1.1em;
    background-image: linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0) 0%,
      rgba(255, 255, 255, 0.8) 5%,
      rgba(255, 255, 255, 1) 100%
    );
    width: 100%;
    height: 20%;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    padding: 0 0 2vh 0;
  }

  .snippet {
    max-height: 35vh;
    overflow: hidden;
  }

</code></pre>

<p>
  To ensure consistency in how the <code class="lang-html">a</code> link gets
  displayed in the snippet, I style it like this:
</p>

<pre><code class="lang-css">  a {
    text-decoration: none;
    color: unset;
    display: block;
  }
</code></pre>

<p>What you get from all this is what you see currently!</p>

<h4><code class="lang-html">id</code></h4>

<p>
  Let's dive first into how the <code class="lang-html">id</code> is generated
  so you can get a better understanding of how it fits into the "Blog Title" as
  well as how we use it to create anchor links for the article and in turn,
  allow using the <code class="lang-html">id</code> to help filter out only the
  current blog article when either given a direct link to the article or when
  reloading the page with that article set in the
  <code class="lang-js">window.location</code>.
</p>

<h5>What's in an <code class="lang-html">id</code>?</h5>

<p>
  Baked into the <code class="lang-html">id</code> are some crucial pieces of
  information. Namely, the date and title of the blog post. These are encoded
  with a <code>-</code> delineator and with the
  <code class="lang-html">html</code> file suffix stripped off, which would
  otherwise have been included when the article file name was returned during
  the original article listing query. This is done primarily to allow a cleaner,
  more conventional looking <code class="lang-html">id</code> attribute.
</p>

<p>
  The kind of information encoded into the
  <code class="lang-html">id</code> allows specific retrieval of that article
  from the Cloud Storage if a user wants to navigate to a page that directly
  presents that article. e.g.
  <a href="https://nathanblair.rocks/blog#2021-August-4-The-Blog"></a> If you
  recall the <code class="lang-js">extract_filter_from_fragment</code> function
  mentioned earlier, there were some string operations done on the
  <code class="lang-html">id</code> in order to generate a filter that could be
  sent when fetching the blog articles. Indeed, it should be clear that the
  first 3 parameters of the <code class="lang-html">id</code> are the
  <code class="lang-js">${DAY}</code>, <code class="lang-js">${MONTH}</code>,
  and <code class="lang-js">${YEAR}</code> (not necessarily in that order), that
  could be used to assemble a filter function for querying that specific article
  from Cloud Storage.
</p>

<p>
  In addition to being able to fetch the correct article itself, the
  <code class="lang-html">id</code> and associated anchor/fragment also allows a
  shareable link to a specific article, which would otherwise be impossible when
  implementing a SPA-aproach. Is at as efficient with respect to having a folder
  for each blog embedded into your website source? I would actually argue its
  <em>more</em> efficient, especially when considering the constraints of using
  only static page hosting services. If the static hosting constraint was taken
  away, there's absolutely other ways to accomplish separating blog source from
  website source, as that's effectively how
  <a href="https://medium.com">medium</a> and other related sites work.
</p>

<p>
  Are fragments as capable as <code>index.html</code>s when it comes to SEO?
  This is a question I've yet to answer fully, but my suspicion is that they
  should be just as effective. The question boils down more to "Is a search
  engine crawler capable of indexing blog articles if they must be retrieved
  from other domains?" I do not have a good answer for this yet.
</p>

<h4>The Blog Network Fetches and <code>src/blog.js</code></h4>

<p>
  The first note to go over is the simple implementation of the default filter,
  discussed previously. The default filter is just a filter passed to the API
  that grabs all articles for the current month. Here's how it works:
</p>

<pre><code class="lang-js">  export function default_filter() {
    const date = new Date()
    const month = DateMap[date.getMonth()]

    return `${date.getFullYear()}/${month}`
  }
</code></pre>

<p>
  Where <code class="lang-js">DateMap</code> is just an
  <code class="lang-js">Object.freeze</code> that serves as a map for inputting
  a given month number and spitting out the month name. e.g. Given
  <code class="lang-js">DateMap[7]</code>, it will return
  <code class="lang-js">"August"</code>
</p>

<p>
  The next point to tackle is
  <code class="lang-js">fetch_blog_articles</code> itself. Recall that this is
  the AsyncGenerator function used in <code>pages/Blog.svelte</code> to iterate
  over to <code class="lang-js">yield</code> each article retrieved from the
  network.
</p>

<p>Lets lay it all out before we step through what its doing and why:</p>

<pre><code class="lang-js">  export async function* fetch_blog_articles(filter) {
    /** @type {Response} */
    let response

    try {
      response = await fetch(`${cloud_host_blog_list_endpoint}${filter()}`)
    } catch (err) {
      console.error(err)
      return
    }

    /** @type {Payload} */
    let body
    try {
      body = await response.json()
    } catch (err) {
      console.error(err)
      return
    }

    if (!Array.isArray(body)) {
      return
    }

    for (const each_entry of body) {
      switch (each_entry.type) {
        case "dir":
          yield* fetch_blog_articles(() => each_entry.path)
          continue
        case "file":
          const date_array = each_entry.path.split("/")
          date_array.pop()
          try {
            yield {
              file_name: each_entry.name,
              // @ts-ignore
              date: date_array,
              content: await (await fetch(each_entry.download_url)).text(),
            }
          } catch (err) {
            console.error(err)
            continue
          }
          break
      }
    }
    return
  }
</code></pre>

<p>
  First, we'll note that it attempts to make the initial network request against
  our Cloud Storage API to list all the articles pertaining to our
  <code class="lang-js">filter</code>.
</p>

<p>
  Pending success of that, it simply parses out the JSON from the network
  request's returned <code class="lang-js">body</code>.
</p>

<p>
  The rest of this is very Cloud Storage-dependent, but let's walk through how
  it works with GitHub API.
</p>

<p>
  Our returned JSON consists of an array of objects. We can iterate over this
  array, though first it is best to guard against the returned body from the API
  being something unexpected with a
</p>

<pre><code class="lang-js">  if (!Array.isArray(body)) {
    return
  }
</code></pre>

<p>
  Next we simply iterate over <code class="lang-js">each_entry of body</code>.
</p>

<p>
  For GitHub API, <code class="lang-js">each_entry</code> has a property
  <code class="lang-js">type</code> that enumerates whether this entry is a
  <code>dir</code>, a <code>file</code>, a <code>symlink</code>, etc.
</p>

<p>
  If its a directory, we want to recursively call into
  <code class="lang-js">fetch_blog_articles</code> with
  <code class="lang-js">each_entry</code>'s
  <code class="lang-js">path</code> property, which denotes the path to the
  resource relative to the repository root.
</p>

<p>
  To properly yield a recursive <code class="lang-js">AsyncGenerator</code>,
  prefix the function call with <code class="lang-js">yield*</code>. Following
  the return of that function, call, we need to process the next entry in the
  array, so we <code class="lang-js">continue</code>.
</p>

<p>
  If <code class="lang-js">each_entry</code> is instead a <code>file</code>,
  we'll need to grab some information about this file and begin populating the
  necessary parts of our return <code>article</code>.
</p>

<p>
  First, we parse out the date information from
  <code class="lang-js">each_entry.path</code>, splitting the path/date segments
  for easier direct access (recall the references to
  <code class="lang-js">date[2]</code> and so forth).
</p>

<p>
  We are now set to begin <code class="lang-js">yield</code>ing the appropriate
  return <code>article</code>. The file name of the article will be the full
  <code class="lang-js">each_entry.name</code>, which GitHub's API documents as
  being the name entry of the file. It will go on to be parsed into the "Blog
  Title", as discussed previously.
</p>

<p>
  The <code>article</code>'s <code>date</code> property is then set to our
  aforementioned <code class="lang-js">date_array</code>, generated by splitting
  <code class="lang-js">each_entry.path</code>
</p>

<p>
  Finally, the <code>content</code> of the returned article needs to have the
  actual <code class="lang-html">html</code> source embedded in it. To retrieve
  this, we require one more network request to
  <code class="lang-js">each_entry.download_url</code>, which GitHub API
  documents as being the endpoint from which to download the raw data of that
  file.
</p>

<p>
  That is now everything necessary to set up a static website that pulls your
  blog articles from a separate cloud storage to prevent the necessity of
  redeploying your static website for every new blog article!
</p>

<h1>What's with all the name mangling?</h1>

<p>
  For the blog article dates and titles, it is certainly the case that you could
  just include that <code class="lang-html">header</code> information in your
  Blog source <code class="lang-html">html</code> files.
</p>

<p>
  My interest is always in removing as much boilerplate as possible. And the
  information you need to query can be baked into the Blog Article Date. Rather
  than needing to write that <code class="lang-html">header</code> field for
  every single article you write, why not make your initial organization better
  and remove that boilerplate completely?
</p>

<p>
  And so we get some <em>sort of</em> ugly name mangling for the "Blog Article
  Date" and "Blog Title", but I'd consider it a worthy trade-off over having all
  the <code class="lang-html">header</code> boilerplate in every article.
</p>

<h1>Reader View Compatibility</h1>

<p>
  Individual article reading has been tested as being compatible with the
  Firefox Browser and Microsoft Edge Browser.
</p>

<h1>SEO Concerns and Considerations</h1>

<h2>What about <code class="lang-html">head</code> tags/keywords for SEO?</h2>

<p>
  I'm unsure about this yet, as there is currently no implementation for
  including <code class="lang-html">tag</code> or
  <code class="lang-html">keyword</code> information to the document
  <code class="lang-html">head</code>. The information would have to be
  extracted from the blog source, and in an ideal sense, there would be a
  function to extract keywords dynamically and insert them into the document
  <code class="lang-html">head</code> when an individual article is clicked.
</p>

<p>
  I need to put in some work to verify, but I don't see any reason why fragments
  and anchors should be less efficient for SEO.
</p>
