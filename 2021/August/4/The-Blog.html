<p>
  Hosting your blog source files separately from your website source files using
  only <code>git</code> and GitHub Pages - it can't be done!
</p>

<p>
  That's what I was becoming convinced of. I've done some hacking and it turns
  out, with even just a pretty simple logic flow, it <em>can</em> in fact be
  done.
</p>

<h1>The Why</h1>

<p>
  I think we can all agree separation of concern is a good thing; and that its
  much easier to only need to concern yourself with publishing an
  <code>html</code> file rather than an entire website. In addition, blog
  content should be both source-controlled and source-controlled separately from
  the actual website that hosts it.
</p>

<h1>The Flow</h1>

<h2>Overview</h2>

<ul>
  <li>
    Write blog source files and organize them in a directory structure
    representing their date of publish and with a filename that represents their
    title.
  </li>

  <li>
    Source control blog repository in a cloud repository. GitHub works very well
    for this as their API to list directories and grab files from repositories
    is very simple to consume. But I've hacked around to make it work using
    something like Google Firestore as well, and I'm sure S3 buckets could
    potentially work too.
  </li>

  <li>
    Add blog diff, commit, and push your local to your Cloud Host (easier if the
    repository cloud host is also the one serving the files, otherwise you'll
    have to do some more steps to copy the blog articles to your Cloud Storage
    buckets).
  </li>

  <li>
    Publish website that can make API calls to download blog source
    (<code>html</code>) files
  </li>
</ul>

<h2>The Details</h2>

<h3>Cloud Storage</h3>

<p>
  The first order of business is to create the hosting environment for where the
  blog source (i.e. the <code>html</code>) files will actually reside. This can
  work using Cloud Storage solutions like S3 or Google Firestore but I find its
  most efficient to use a GitHub repository, as their API is very easy to
  consume and no extra steps are needed once the local source control is synced
  with the cloud.
</p>

<aside>
  Discussing setting up for a cloud storage host other than GitHub is outside
  the scope of this blog post. If people are interested in how Google Firestore
  or AWS S3 might work, send me a mention
  <a href="https://twitter.com/NateTBlair">@NateTBlair</a>
</aside>

<h4>GitHub</h4>

<p>
  For GitHub, its a simple matter of creating a repository that's solely meant
  for source-controlling your blog post source files (the
  <code>html</code> files).
</p>

<p>
  This method is most effective (and the assumption throughout the rest of the
  guide) when there is also a directory structure expected. Its very simple:
</p>

<ul>
  <li>
    <code>Year</code>
    <ul>
      <li>
        <code>Month</code>
        <ul>
          <li>
            <code>Day</code>
            <ul>
              <li>
                <code>Blog-Post.html</code>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>
  This will end up with a blog post shown on the website for the date
  <code>${Day} ${Month} ${Year}</code> and the title <b>Blog Post</b>.
</p>

<p>
  Feel free to either create the repository in GitHub first and clone it down or
  initialize the local <code>git</code> repo and add the created GitHub remote
  repository to the existing local one.
</p>

<p>
  Make sure you are set to commit and sync to your remote's default branch (I
  simply <code>git config --global init.defaultBranch "default"</code>).
</p>

<p>
  Simply write the <code>Blog-Post.html</code> file at the desired date folder
  structure location,
  <code>git add ${Year}/${Month}/${Day}/Blog-Post.html</code>,
  <code>git commit -m "${YOUR_COMMIT_MESSAGE}"</code>, and then
  <code>git push</code> (<code>-u ${REMOTE_NAME} ${DEFAULT_BRANCH}</code> if
  you're not already set up to sync to that branch by default).
</p>

<p>
  This takes care of everything that needs to be done to the blog article
  <code>html</code> file itself. With the source now available from a Cloud
  Storage host, we just need to fetch it and insert it into our Blog page.
</p>

<h3>Website Blog Page Logic</h3>

<p>
  The details of this will be very dependent upon how your site is designed and
  what kind of frameworks you use. I can't account for everything in a single
  article so I'll divulge my process while using
  <code><a href="https://svelte.dev/">svelte</a></code> and you can feel free to
  modify the process to fit your needs accordingly.
</p>

<h4>Svelte Pages and Routing</h4>

<p>
  I don't use any extra special <code>svelte</code> frameworks to manage
  single-page routing. I have a <code>blog/index.html</code> path inside my
  hosted root folder, and that <code>index.html</code> file points to the same
  <code>main.js</code> and other assets that my <code>/index.html</code> file
  do. In the end, it ends up just serving my <code>Blog.svelte</code> component.
  To see it in action, check out my
  <code
    ><a
      href="https://github.com/nathanblair/nathanblair.github.io/blob/default/src/App.svelte"
      >App.svelte</a
    ></code
  >
  file and my
  <code
    ><a
      href="https://github.com/nathanblair/nathanblair.github.io/blob/default/src/pages/Blog.svelte"
      >pages/Blog.svelte</a
    ></code
  >
  file.
</p>

<p>
  Speaking of that <code>pages/Blog.svelte</code> file, let's dive into what its
  doing to load our Blog articles from the Cloud Storage host.
</p>

<h4>
  <a name="BlogPage"></a>
  <code>pages/Blog.svelte</code>
</h4>

<p>
  Most of the functionality for network requests is actually handled in a
  <code>Javascript</code> module located in <code>src/blog.js</code>, but let's
  first dive into what must be done from a high-level before digging into the
  implementation details.
</p>

<p>
  One of the first things we need is a DOM element for targeting where to insert
  each Blog Article. For the time being (until I get reverse-chronological
  sorting implemented) I simply target the
  <code>document.getElementById(main_id)</code>. This just appends each Blog
  Article that is fetched as siblings to one another in my DOM's
  <code>main</code> element. It may be appropriate to target your blog articles
  to your <code>document.body</code>.
</p>

<p>
  The next piece of information we'll need is to evaluate the current context to
  determine what kind of filter to use to fetch blog articles.
</p>

<p>
  For example, since we're not navigating to the blog
  <code>index.html</code> pages directly, we need to know if our current
  <code>window.location</code> indicates the user is attempting to view an
  article directly. Otherwise, we'll want to fetch a mixture of blog articles
  from the current time to say, 30 days previous?
</p>

<p>
  That filter, in turn, is what we'll be using in our API calls. Note that we've
  set up the blog directory structure for pretty easy querying. If you're using
  something like Firestore or another Cloud Storage you could take advantage of
  different query indices to optimize the API calls you're making and better
  tailor your filtering function.
</p>

<p>
  The first logic check is then to have a look at the
  <code>window.location.hash</code>.
</p>

<pre><code>
  function extract_filter_from_fragment() {
    return window.location.hash
      .replace(/^#/, "")
      .split("-")
      .slice(0, 3)
      .join("/")
  }
</code></pre>

<p>
  The string operations going on here will make more sense later once we discuss
  how we set the <code>id</code> of each blog article. Essentially, we're
  stripping out the first 3 sections out of the url fragment (delineated by
  <code>-</code>'s), which encode the <code>${DAY}</code>,
  <code>${MONTH}</code>, and <code>${YEAR}</code> and reformatting them into a
  string of the format <code>"${YEAR}/${MONTH}/${DAY}"</code>. This is
  compatible with the way we're able to "query" data using the GitHub API and it
  fits our directory model.
</p>

<p>&#128077;</p>

<p>
  We'll cache this result in
  <code>const fragment = extract_filter_from_fragment()</code> and then check if
  that returns empty. If it does not, we know that's what we should set the
  filter to, otherwise, we'll use a default filter to fetch some timeline of
  blog articles at our discretion (or present the user with some control that
  allows narrowing down the time for the filter). It looks like:
</p>

<pre><code>
    let filter = fragment === "" ? default_filter : () => fragment
</code></pre>

<p>
  Note that the <code>filter</code> is cached to a callback.
  <code>default_filter</code> is some function at our discretion that will pull
  in some desired amount/timeline of blog articles.
</p>

<p>
  We can now concern ourselves with passing in our <code>filter</code> callback
  function to the call that will return an iterable of blog articles.
  Specifically, I like the idea of using <code>Generators</code> to
  <code>yield</code> each Article as it is processed from the Cloud Storage, and
  so under the hood, our <code>for</code> loop that iterates on each retrieved
  article will be iterating over a <code>Generator</code>. Again, we'll take a
  look at this function a bit later.
</p>

<p>
  For now, here's what our full function will look like to grab and populate
  articles on our Blog page. Note the <code>BlogArticle</code> component, we'll
  dive into that shortly as well.
</p>

<pre><code>
  async function populate_blogs() {
    const fragment = extract_filter_from_fragment()
    let filter = fragment === "" ? default_filter : () => fragment
    for await (const each_article of fetch_blog_articles(filter)) {
      new BlogArticle({
        target: root_element,
        props: {
          blog_file_name: each_article.file_name,
          date: each_article.date,
          content: each_article.content,
        },
      })
    }
  }
</code></pre>

<p>
  As of now there is no way to initialize a slot when creating a
  <code>Svelte</code> Component via Javascript. And we must create the Component
  instance using Javascript because <code>Svelte</code> hasn't yet implemented
  the <code>{#await :then}</code> and <code>{#each}</code> pattern for
  <code>AsyncGenerator</code>s yet. Our
  <code>fetch_blog_articles</code> function is <code>async</code> because it
  will be awaiting network <code>fetch</code>es.
</p>

<p>
  At the end of our <code>pages/Blog.svelte</code> Component script, we can make
  a call to this function without needing to <code>await</code> its return:
</p>

<pre><code>
&lt;script&gt;
  ...
  populate_blogs()
  ...
&lt;/script&gt;
</code></pre>

<h4><code>components/BlogArticle.svelte</code></h4>

<p>
  With the main Blog page set up to fetch blog articles, its now appropriate to
  lay out what each article will look like. <code>Svelte</code> makes templating
  up each article into a similar layout and design a very trivial task.
</p>

<p>
  Taking a look at the most basic properties of a <code>BlogArticle</code>, we
  obviously have a "Blog Article Title" as well as a "Blog Article Date".
</p>

<p>
  The title of the blog is a parsed value that comes from the article file name
  as it is in the Cloud Storage provider. We'll handle parsing the file name
  into the title itself a little later, but for now we know we need to expose a
  property for the file name to be set when instantiating the Component.
</p>

<p>
  You're free to represent your dates the way you want to; its easiest to keep
  the date format consistent between how its displayed in the blog page and how
  you store it in the original blog repository. e.g. I display my blogs in the
  format
  <code>"$DD $FULL_MONTH $YEAR</code>. But you could display them as
  <code>$DD $MM $YY</code> if that suited your intuition better. Either way,
  we'll expose a <code>date</code> property for passing in the date of the blog
  article, known at the time of fetching it from the Cloud Storage provider as
  it will be the path to the actual file.
</p>

<p>
  Since we're not allowed to pass in slots directly when we instantiate Svelte
  Components from Javascript, we'll also have to pass in the
  <code>html</code> content of the blog as a Component property. We'll then need
  to expose a <code>content</code> property for passing in the raw
  <code>html</code> content of the retrieved file.
</p>

<p>
  That covers the input properties of the <code>BlogArticle</code> Component
  that it needs to create itself. Note that these are consistent with the
  properties set when we instantiate the <code>BlogArticle</code> from the
  <a href="#BlogPage"><code>pages/Blog.svelte</code> Component</a>.
</p>

<pre><code>
  // components/BlogArticle.svelte

  &lt;script&gt;
    ...

    /** @type {string} */
    export let blog_file_name

    /** @type {import("../blog.js").ArticleDateArray} */
    export let date

    /** @type {string} */
    export let content

    ...
  &lt;script&gt;

  ...
</code></pre>

<p>
  We know the properties the BlogArticle will need to display, so let's wire up
  the layout for it.
</p>

<pre><code>
  &lt;a href={"#" + id} on:click={toggle_article_expansion} bind:this={article_link}&gt;
    &lt;article {id}&gt;
      &lt;header&gt;
        &lt;h1 class="article-date">{day} {month} {year}&lt;/h1&gt;
        &lt;h2 class="article-title">{parse_blog_file_name()}&lt;/h2&gt;
      &lt;/header&gt;
      &lt;div class="article-content hidden" bind:this={content_accessor}&gt;
        {@html content}
      &lt;/div&gt;
      &lt;p class="snippet" bind:this={snippet_accessor}&gt;{@html snippet}&lt;/p&gt;
    &lt;/article&gt;
  &lt;/a&gt;
</code></pre>

<p>
  There's quite a bit buried in there that hasn't been addressed yet, so let's
  pick it apart. Starting with the <code>header</code> as that is the
  information we just finished setting up to be collected.
</p>

<p>
  The <code>header</code> has to values it displays: the "Blog Article Title"
  and the "Blog Date".
</p>

<h4>Blog Date</h4>

<p>
  The Blog Date is a trivial substituion whose components are
  <code>const</code>ants set from parsing our input property <code>date</code>.
  Its very simply:
</p>

<pre><code>
  const year = date[0]
  const month = date[1]
  const day = date[2]
</code></pre>

<h4>Blog Title</h4>

<p>
  As mentioned previously, there's a little more parsing going on here to
  generate the Blog Title, but we have all the information we need to parse it.
  We're simply looking at the <code>blog_file_name</code> input parameter and
  doing some very trivial string operations on it:
</p>

<pre><code>
  function parse_blog_file_name() {
    return id.split("-").slice(3).join(" ")
  }
</code></pre>

<p>
  You should notice the <code>blog_file_name</code> isn't used directly, but
  instead the <code>id</code>. This <code>id</code> will be the
  <code>id</code> attribute of the article and it is calculated from another
  couple simple string operations:
</p>

<pre><code>
  const id = year + "-" + month + "-" + day + "-" + blog_file_name.replace(".html", "")
</code></pre>

<h4><code>id</code></h4>

<p>
  Let's dive first into how the <code>id</code> is generated so you can get a
  better understanding of how it fits into the "Blog Title" as well as how we
  use it to create anchor links for the article and in turn, allow using the
  <code>id</code> to help filter out only the current blog article when either
  given a direct link to the article or when reloading the page with that
  article set in the <code>window.location</code>.
</p>

<h4>Blog Article Behaviors</h4>

<h3>Writing and Committing</h3>

<h1>What's will all the name mangling?</h1>

<p>
  For the blog article dates and titles, it is certainly the case that you could
  just include that <code>header</code> information in your Blog source
  <code>html</code> files.
</p>

<p>
  My interest is always in removing as much boilerplate as possible. And the
  information you need to query can be baked into the Blog Article Date. Rather
  than needing to write that <code>header</code> field for every single article
  you write, why not make your initial organization better and remove that
  boilerplate completely?
</p>

<p>
  And so we get some <em>sort of</em> ugly name mangling for the "Blog Article
  Date" and "Blog Title", but I'd consider it a worthy trade of over having all
  the <code>header</code> boilerplate in every article.
</p>

<h1>Sharing Posts and Anchor Links</h1>

<h1>SEO Concerns and Considerations</h1>

<h2>
  <em><b>FINISH ME</b></em>
</h2>

<p>I need to put in some work to verify, but I believe</p>
