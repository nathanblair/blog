<p>
  Hosting your blog source files separately from your website source files using
  only <code>git</code> and GitHub Pages - it can't be done!
</p>

<p>
  That's what I was becoming convinced of. I've done some hacking and it turns
  out, with even just a pretty simple logic flow, it <em>can</em> in fact be
  done.
</p>

<em>This page needs synced up with the current Blog implementation</em>

<em>
  This will probably be left half-finished until I wrap up the Blog Article
  Placeholder implementation
</em>

<h1>The Why</h1>

<p>
  I think we can all agree separation of concern is a good thing; and that its
  much easier to only need to concern yourself with publishing an
  <code class="lang-html">html</code> file rather than an entire website. In
  addition, blog content should be both source-controlled and source-controlled
  separately from the actual website that hosts it.
</p>

<p>
  And the way this source-control directory structure is set up, we can
  certainly have multiple branches open while working on multiple blog posts.
  And merging them will hardly ever create a merge conflict!
</p>

<h2>Blog Article Behaviors</h2>

<p>
  In my eyes, I think it is most intuitive when visiting a Blog page to view a
  list of blogs, with their date, title, and a snippet of them visible as part
  of a list spanning some section of time.
</p>

<p>
  I can peruse the article list at my discretion and should I find something
  that sounds intereseting to read, I would like to click on that snippet and
  view the full article contents without losing my context of where I am in
  browsing the blog list.
</p>

<p>
  This point is addressed by leaning on an article
  <code class="lang-html">id</code> and URL fragments that will be discussed
  more later. We will set a link in the article snippet that is show that opens
  the full article in a new tab when clicked. This new tab allows reloading the
  page to view the same article, sharing the direct article link using the same
  URL, or we can close the article page without having to worry about losing our
  position in the blog list.
</p>

<h1>The Workflow</h1>

<h2>Overview</h2>

<ul>
  <li>
    Write blog source files and organize them in a directory structure
    representing their date of publish and with a filename that represents their
    title.
  </li>

  <li>
    Source control blog repository in a cloud repository. GitHub works very well
    for this as their API to list directories and grab files from repositories
    is very simple to consume. But I've hacked around to make it work using
    something like Google Firestore as well, and I'm sure S3 buckets could
    potentially work too.
  </li>

  <li>
    Add blog diff, commit, and push your local to your Cloud Host (easier if the
    repository cloud host is also the one serving the files, otherwise you'll
    have to do some more steps to copy the blog articles to your Cloud Storage
    buckets).
  </li>

  <li>
    Publish website that can make API calls to download blog source (<code
      class="lang-html"
      >html</code
    >) files
  </li>
</ul>

<h2>The Details</h2>

<h3>Cloud Storage</h3>

<p>
  The first order of business is to create the hosting environment for where the
  blog source (i.e. the <code class="lang-html">html</code>) files will actually
  reside. This can work using Cloud Storage solutions like S3 or Google
  Firestore but I find its most efficient to use a GitHub repository, as their
  API is very easy to consume and no extra steps are needed once the local
  source control is synced with the cloud.
</p>

<aside>
  Discussing setting up for a cloud storage host other than GitHub is outside
  the scope of this blog post. If people are interested in how Google Firestore
  or AWS S3 might work, send me a mention
  <a href="https://twitter.com/NateTBlair">@NateTBlair</a>
</aside>

<h4>GitHub</h4>

<p>
  For GitHub, its a simple matter of creating a repository that's solely meant
  for source-controlling your blog post source files (the
  <code class="lang-html">html</code> files).
</p>

<p>
  This method is most effective (and the assumption throughout the rest of the
  guide) when there is also a directory structure expected. Its very simple:
</p>

<ul>
  <li>
    <code>Year</code>
    <ul>
      <li>
        <code>Month</code>
        <ul>
          <li>
            <code>Day</code>
            <ul>
              <li>
                <code>Blog-Post.html</code>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>
  This will end up with a blog post shown on the website for the date
  <code class="lang-js">${Day} ${Month} ${Year}</code> and the title
  <b>Blog Post</b>.
</p>

<p>
  Feel free to either create the repository in GitHub first and clone it down or
  initialize the local <code>git</code> repo and add the created GitHub remote
  repository to the existing local one.
</p>

<p>
  Make sure you are set to commit and sync to your remote's default branch (I
  simply <code>git config --global init.defaultBranch "default"</code>).
</p>

<p>
  Simply write the <code>Blog-Post.html</code> file at the desired date folder
  structure location,
  <code>git add ${Year}/${Month}/${Day}/Blog-Post.html</code>,
  <code>git commit -m "${YOUR_COMMIT_MESSAGE}"</code>, and then
  <code>git push</code> (<code>-u ${REMOTE_NAME} ${DEFAULT_BRANCH}</code> if
  you're not already set up to sync to that branch by default).
</p>

<p>
  This takes care of everything that needs to be done to the blog article
  <code class="lang-html">html</code> file itself. With the source now available
  from a Cloud Storage host, we just need to fetch it and insert it into our
  Blog page.
</p>

<h3>Website Blog Page Logic</h3>

<p>
  The details of this will be very dependent upon how your site is designed and
  what kind of frameworks you use. I can't account for everything in a single
  article so I'll divulge my process while using
  <code><a href="https://svelte.dev/">svelte</a></code> and you can feel free to
  modify the process to fit your needs accordingly.
</p>

<h4>Svelte Pages and Routing</h4>

<p>
  I don't use any extra special <code>svelte</code> frameworks to manage
  single-page routing. I have a <code>blog/index.html</code> path inside my
  hosted root folder, and that <code>index.html</code> file points to the same
  <code>main.js</code> and other assets that my <code>/index.html</code> file
  do. In the end, it ends up just serving my <code>Blog.svelte</code> component.
  To see it in action, check out my
  <code
    ><a
      href="https://github.com/nathanblair/nathanblair.github.io/blob/default/src/App.svelte"
      >App.svelte</a
    ></code
  >
  file and my
  <code
    ><a
      href="https://github.com/nathanblair/nathanblair.github.io/blob/default/src/pages/Blog.svelte"
      >pages/Blog.svelte</a
    ></code
  >
  file.
</p>

<p>
  Speaking of that <code>pages/Blog.svelte</code> file, let's dive into what its
  doing to load our Blog articles from the Cloud Storage host.
</p>

<h4>
  <a name="BlogPage"></a>
  <code>pages/Blog.svelte</code>
</h4>

<p>
  Most of the functionality for network requests is actually handled in a
  <code>Javascript</code> module located in <code>src/blog.js</code>, but let's
  first dive into what must be done from a high-level before digging into the
  implementation details.
</p>

<p>
  One of the first things we need is a DOM element for targeting where to insert
  each Blog Article. For the time being (until I get reverse-chronological
  sorting implemented) I simply target the
  <code class="lang-js">document.getElementById(main_id)</code>. This just
  appends each Blog Article that is fetched as siblings to one another in my
  DOM's <code class="lang-html">main</code> element. It may be appropriate to
  target your blog articles to your <code class="lang-js">document.body</code>.
</p>

<p>
  The next piece of information we'll need is to evaluate the current context to
  determine what kind of filter to use to fetch blog articles.
</p>

<p>
  For example, since we're not navigating to the blog
  <code>index.html</code> pages directly, we need to know if our current
  <code class="lang-js">window.location</code> indicates the user is attempting
  to view an article directly. Otherwise, we'll want to fetch a mixture of blog
  articles from the current time to say, 30 days previous?
</p>

<p>
  That filter, in turn, is what we'll be using in our API calls. Note that we've
  set up the blog directory structure for pretty easy querying. If you're using
  something like Firestore or another Cloud Storage you could take advantage of
  different query indices to optimize the API calls you're making and better
  tailor your filtering function.
</p>

<p>
  The first logic check is then to have a look at the
  <code class="lang-js">window.location.hash</code>.
</p>

<pre><code class="lang-js">  function extract_filter_from_fragment() {
    return window.location.hash
      .replace(/^#/, "")
      .split("-")
      .slice(0, 3)
      .join("/")
  }
</code></pre>

<p>
  The string operations going on here will make more sense later once we discuss
  how we set the <code class="lang-html">id</code> of each blog article.
  Essentially, we're stripping out the first 3 sections out of the url fragment
  (delineated by <code>-</code>'s), which encode the
  <code class="lang-js">${DAY}</code>, <code class="lang-js">${MONTH}</code>,
  and <code class="lang-js">${YEAR}</code> and reformatting them into a string
  of the format <code class="lang-js">"${YEAR}/${MONTH}/${DAY}"</code>. This is
  compatible with the way we're able to "query" data using the GitHub API and it
  fits our directory model.
</p>

<p>&#128077;</p>

<p>
  We'll cache this result in
  <code class="lang-js">const fragment = extract_filter_from_fragment()</code>
  and then check if that returns empty. If it does not, we know that's what we
  should set the filter to, otherwise, we'll use a default filter to fetch some
  timeline of blog articles at our discretion (or present the user with some
  control that allows narrowing down the time for the filter). It looks like:
</p>

<pre><code class="lang-js">  let filter = fragment === "" ? default_filter : () => fragment</code></pre>

<p>
  Note that the <code class="lang-js">filter</code> is cached to a callback.
  <code class="lang-js">default_filter</code> is some function at our discretion
  that will pull in some desired amount/timeline of blog articles.
</p>

<p>
  We can now concern ourselves with passing in our
  <code class="lang-js">filter</code> callback function to the call that will
  return an iterable of blog articles. Specifically, I like the idea of using
  <code class="lang-js">Generators</code> to
  <code class="lang-js">yield</code> each Article as it is processed from the
  Cloud Storage, and so under the hood, our
  <code class="lang-js">for</code> loop that iterates on each retrieved article
  will be iterating over a <code class="lang-js">Generator</code>. Again, we'll
  take a look at this function a bit later.
</p>

<p>
  For now, here's what our full function will look like to grab and populate
  articles on our Blog page. Note the <code>BlogArticle</code> component, we'll
  dive into that shortly as well.
</p>

<pre><code class="lang-js">  async function populate_blogs() {
    const fragment = extract_filter_from_fragment()
    let filter = fragment === "" ? default_filter : () => fragment
    for await (const each_article of fetch_blog_articles(filter)) {
      new BlogArticle({
        target: root_element,
        props: {
          blog_file_name: each_article.file_name,
          date: each_article.date,
          content: each_article.content,
        },
      })
    }
  }
</code></pre>

<p>
  As of now there is no way to initialize a slot when creating a
  <code>Svelte</code> Component via Javascript. And we must create the Component
  instance using Javascript because <code>Svelte</code> hasn't yet implemented
  the <code>{#await :then}</code> and <code>{#each}</code> pattern for
  <code class="lang-js">AsyncGenerator</code>s yet. Our
  <code class="lang-js">fetch_blog_articles</code> function is
  <code class="lang-js">async</code> because it will be awaiting network
  <code class="lang-js">fetch</code>es.
</p>

<p>
  At the end of our <code>pages/Blog.svelte</code> Component script, we can make
  a call to this function without needing to
  <code class="lang-js">await</code> its return:
</p>

<pre><code class="lang-html">  &lt;script&gt;
    ...
    populate_blogs()
    ...
  &lt;/script&gt;
</code></pre>

<h4><code>components/BlogArticle.svelte</code></h4>

<p>
  With the main Blog page set up to fetch blog articles, its now appropriate to
  lay out what each article will look like. <code>Svelte</code> makes templating
  up each article into a similar layout and design a very trivial task.
</p>

<p>
  Taking a look at the most basic properties of a <code>BlogArticle</code>, we
  obviously have a "Blog Article Title" as well as a "Blog Article Date".
</p>

<p>
  The title of the blog is a parsed value that comes from the article file name
  as it is in the Cloud Storage provider. We'll handle parsing the file name
  into the title itself a little later, but for now we know we need to expose a
  property for the file name to be set when instantiating the Component.
</p>

<p>
  You're free to represent your dates the way you want to; its easiest to keep
  the date format consistent between how its displayed in the blog page and how
  you store it in the original blog repository. e.g. I display my blogs in the
  format
  <code class="lang-js">"${DD} ${FULL_MONTH} ${YEAR}"</code>. But you could
  display them as <code class="lang-js">"${DD} ${MM} ${YY}"</code> if that
  suited your intuition better. Either way, we'll expose a
  <code>date</code> property for passing in the date of the blog article, known
  at the time of fetching it from the Cloud Storage provider as it will be the
  path to the actual file.
</p>

<p>
  Since we're not allowed to pass in slots directly when we instantiate Svelte
  Components from Javascript, we'll also have to pass in the
  <code class="lang-html">html</code> content of the blog as a Component
  property. We'll then need to expose a
  <code class="lang-html">content</code> property for passing in the raw
  <code class="lang-html">html</code> content of the retrieved file.
</p>

<p>
  That covers the input properties of the <code>BlogArticle</code> Component
  that it needs to create itself. Note that these are consistent with the
  properties set when we instantiate the <code>BlogArticle</code> from the
  <a href="#BlogPage"><code>pages/Blog.svelte</code> Component</a>.
</p>

<pre><code class="lang-html">  // components/BlogArticle.svelte
  &lt;script&gt;
    ...

    /** @type {string} */
    export let blog_file_name

    /** @type {import("../blog.js").ArticleDateArray} */
    export let date

    /** @type {string} */
    export let content

    ...
  &lt;script&gt;

  ...
</code></pre>

<p>
  We know the properties the BlogArticle will need to display, so let's wire up
  the layout for it.
</p>

<pre><code class="lang-html">  &lt;article {id} class={card_class_name} bind:this={article_accessor}&gt;
    &lt;header&gt;
      &lt;h1 class="article-date">{day} {month} {year}&lt;/h1&gt;
      &lt;h2 class="article-title">{parse_blog_file_name()}&lt;/h2&gt;
    &lt;/header&gt;
    {#if full_article_shown}
      {@html content}
    {:else}
      &lt;a
        href={"#" + id}
        target="_blank"
        class="overlay snippet"
        bind:this={article_anchor_accessor}
      &gt;
        {@html content}
      &lt;/a&gt;
    {/if}
  &lt;/article&gt;
</code></pre>

<p>
  There's quite a bit buried in there that hasn't been addressed yet, so let's
  pick it apart. Starting with the <code class="lang-html">header</code> as that
  is the information we just finished setting up to be collected.
</p>

<p>
  The <code class="lang-html">header</code> has two values it displays: the
  "Blog Article Title" and the "Blog Date".
</p>

<h4>Blog Date</h4>

<p>
  The Blog Date is a trivial substituion whose components are
  <code class="lang-js">const</code>ants set from parsing our input property
  <code>date</code>. Its very simply:
</p>

<pre><code class="lang-js">  const year = date[0]
  const month = date[1]
  const day = date[2]
</code></pre>

<h4>Blog Title</h4>

<p>
  As mentioned previously, there's a little more parsing going on here to
  generate the Blog Title, but we have all the information we need to parse it.
  We're simply looking at the <code class="lang-js">blog_file_name</code> input
  parameter and doing some very trivial string operations on it:
</p>

<pre><code class="lang-js">  function parse_blog_file_name() {
    return id.split("-").slice(3).join(" ")
  }
</code></pre>

<p>
  You should notice the <code class="lang-js">blog_file_name</code> isn't used
  directly, but instead the <code class="lang-html">id</code>. This
  <code class="lang-html">id</code> will be the
  <code class="lang-html">id</code> attribute of the article and it is
  calculated from another couple simple string operations:
</p>

<pre><code class="lang-js">  const id = year + "-" + month + "-" + day + "-" + blog_file_name.replace(".html", "")</code></pre>

<p>
  We'll get more into the <code class="lang-html">id</code> in just a moment,
  but let's return to look at the rest of the Component to understand how it
  works with our desired behavior.
</p>

<h4>Tracking Desire to View Full Blog</h4>

<p>
  Since the <code>BlogArticle</code> Component can be instantiated from either a
  page listing numerous articles or from a desire to view only that single
  article, we have to differentiate those cases. We can do this with the help of
  the <code class="lang-html">id</code>/fragment of the URL.
</p>

<p>
  If there's a desire to view only a single blog article, the
  <code class="lang-js">window.location.hash</code> will be set to the
  <code class="lang-html">id</code> of the article.
</p>

<pre><code class="lang-js">  const full_article_shown = window.location.hash.replace("#", "") === id</code></pre>

<p>
  We can then use <code class="lang-js">full_article_shown</code> to set up a
  couple different scenarios.
</p>

<p>
  Recall that the Component <code class="lang-html">html</code> used an
  <code>{#if}</code> check for the value of
  <code class="lang-js">full_article_shown</code>. If the full article is
  desired to be shown, the only portion that is rendered for the content portion
  of the Component is the <code class="lang-js">content</code> passed in from
  the instantiation of the <code>BlogArticle</code>, evaluated as
  <code class="lang-html">html</code>.
</p>

<p>
  Sure, there are security considerations here regarding injecting the
  <code class="lang-js">content</code> and evaluating its
  <code class="lang-html">html</code>, but I wager if your blog content has its
  <code class="lang-js">content</code> compromised, you've got bigger worries on
  your hands than <code class="lang-html">html</code>-injection. Namely, that
  your entire GitHub account is compromised, or your Cloud Storage credentials
  are compromised. Yuck. &#129326;
</p>

<p>
  One of the other parameters that depends upon the
  <code class="lang-js">full_article_shown</code> state is whether to show the
  <code class="lang-html">article</code> element as a "card". This is simply a
  styling choice to give each <code class="lang-html">article</code> a look of
  being raised from the page slightly, which makes the link-clicking behavior
  more intuitive.
</p>

<pre><code class="lang-js">  // Inside script tag of Component
  ...
  const card_class_name = full_article_shown ? "" : "card"
  ...
</code></pre>

<pre><code class="lang-css">  /* Inside style tag of Component */
  ...
  .card {
    border: solid 1px;
    box-shadow: 0 0 4px;
    padding: 2vh;
    margin: 2vh 2vw;
  }
  ...
</code></pre>

<p>
  Other styling applied like the <code class="lang-css">overlay</code> and
  <code class="lang-css">snippet</code> classes are used for helping to create a
  "snippet"-style look of the article in the list of articles.
</p>

<pre><code class="lang-css">  /* Component style tag */
  .overlay {
    position: relative;
  }

  .overlay::after {
    content: "";
    position: absolute;
    z-index: 1;
    bottom: 0;
    left: 0;
    pointer-events: none;
    background-image: linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0),
      rgba(255, 255, 255, 1) 90%
    );
    width: 100%;
    height: 100%;
  }

  .snippet {
    max-height: 20vh;
    overflow: hidden;
  }
</code></pre>

<p>
  To ensure consistency in how the <code class="lang-html">a</code> link gets
  displayed in the snippet, I style it like this:
</p>

<pre><code class="lang-css">  a {
    text-decoration: none;
    color: unset;
    display: block;
  }
</code></pre>

<p>What you get from all this is what you see currently!</p>

<h4><code class="lang-html">id</code></h4>

<p>
  Let's dive first into how the <code class="lang-html">id</code> is generated
  so you can get a better understanding of how it fits into the "Blog Title" as
  well as how we use it to create anchor links for the article and in turn,
  allow using the <code class="lang-html">id</code> to help filter out only the
  current blog article when either given a direct link to the article or when
  reloading the page with that article set in the
  <code class="lang-js">window.location</code>.
</p>

<h5>What's in an <code class="lang-html">id</code>?</h5>

<p>
  Baked into the <code class="lang-html">id</code> are some crucial pieces of
  information. Namely, the date and title of the blog post. These are encoded
  with a <code>-</code> delineator and with the
  <code class="lang-html">html</code> file suffix stripped off, which would
  otherwise have been included when the article file name was returned during
  the original article listing query. This is done primarily to allow a cleaner,
  more conventional looking <code class="lang-html">id</code> attribute.
</p>

<p>
  The kind of information encoded into the
  <code class="lang-html">id</code> allows specific retrieval of that article
  from the Cloud Storage if a user wants to navigate to a page that directly
  presents that article. e.g.
  <a href="https://nathanblair.rocks/blog#2021-August-4-The-Blog"></a> If you
  recall the <code class="lang-js">extract_filter_from_fragment</code> function
  mentioned earlier, there were some string operations done on the
  <code class="lang-html">id</code> in order to generate a filter that could be
  sent when fetching the blog articles. Indeed, it should be clear that the
  first 3 parameters of the <code class="lang-html">id</code> are the
  <code class="lang-js">${DAY}</code>, <code class="lang-js">${MONTH}</code>,
  and <code class="lang-js">${YEAR}</code> (not necessarily in that order), that
  could be used to assmble a filter function for querying that specific article
  from Cloud Storage.
</p>

<p>
  In addition to being able to fetch the correct article itself, it also allows
  a direct shareable link to a specific article, which would otherwise be
  impossible when implementing a SPA-aproach. Is at as efficient with respect to
  having a folder for each blog embedded into your website source? I would
  actually argue its <em>more</em> efficient, especially when considering the
  constraints of using only static page hosting services. If the static hosting
  constraint was taken away, there's absolutely other ways to accomplish
  separating blog source from website source, as that's effectively how
  <a href="https://medium.com">medium</a> and other related sites work.
</p>

<p>
  Are fragments as capable as <code>index.html</code>s when it comes to SEO?
  This is a question I've yet to answer fully, but my suspicion is that they
  should be just as effective. The question boils down more to "Is a search
  engine crawler capable of indexing blog articles if they must be retrieved
  from other domains?" I do not have a good answer for this yet.
</p>

<h4>The Blog Network Fetches and <code>src/blog.js</code></h4>

<p><em>TODO</em></p>

<h3>Writing and Committing</h3>

<p>
  To make sure the Blog page is able to fetch your blog, you'll have to make
  sure you commit your article to the Blog source repository and sync those
  changes to the remote repository on the default branch. If you're using
  another Cloud Stroage provider you'll also want to be sure to upload the blog
  source file there as well.
</p>

<h1>What's with all the name mangling?</h1>

<p>
  For the blog article dates and titles, it is certainly the case that you could
  just include that <code class="lang-html">header</code> information in your
  Blog source <code class="lang-html">html</code> files.
</p>

<p>
  My interest is always in removing as much boilerplate as possible. And the
  information you need to query can be baked into the Blog Article Date. Rather
  than needing to write that <code class="lang-html">header</code> field for
  every single article you write, why not make your initial organization better
  and remove that boilerplate completely?
</p>

<p>
  And so we get some <em>sort of</em> ugly name mangling for the "Blog Article
  Date" and "Blog Title", but I'd consider it a worthy trade-off over having all
  the <code class="lang-html">header</code> boilerplate in every article.
</p>

<h1>Reader View Compatibility</h1>

<p>
  Individual article reading has been tested as being compatible with the
  Firefox Browser.
</p>

<h1>SEO Concerns and Considerations</h1>

<h2>What about <code class="lang-html">head</code> tags/keywords for SEO?</h2>

<p>
  I'm unsure about this yet, as there is currently no implementation for
  including <code class="lang-html">tag</code> or
  <code class="lang-html">keyword</code> information to the document
  <code class="lang-html">head</code>. The information would have to be
  extracted from the blog source, and in an ideal sense, there would be a
  function to extract keywords dynamically and insert them into the document
  <code class="lang-html">head</code> when an individual article is clicked.
</p>

<h2>
  <em><b>FINISH ME</b></em>
</h2>

<p>
  I need to put in some work to verify, but I don't see any reason why fragments
  and anchors should be less efficient for SEO.
</p>
